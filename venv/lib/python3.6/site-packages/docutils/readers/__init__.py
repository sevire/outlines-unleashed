# $Id: __init__.py 8239 2018-11-21 21:46:00Z milde $
# Authors: David Goodger <goodger@python.org>; Ueli Schlaepfer
# Copyright: This module has been placed in the public domain.

"""
This package contains Docutils Reader modules.
"""

__docformat__ = 'reStructuredText'

import sys

from docutils import utils, parsers, Component
from docutils.transforms import universal


class Reader(Component):

    """Abstract base class for docutils Readers.

    Each reader module or package must export a subclass also called
    'Reader'.

    The two steps of a Reader's responsibility are to read data from the
    source Input object and parse the data with the Parser object. Call `read()`
    to process a document.
    """

    component_type = 'reader'
    config_section = 'readers'

    def get_transforms(self):
        return Component.get_transforms(self) + [
            universal.Decorations,
            universal.ExposeInternals,
            universal.StripComments,]

    def __init__(self, parser=None, parser_name=None):
        """Initialize the Reader instance.

        Several instance attributes are defined with dummy initial values.
        Subclasses may use these attributes as they wish.

        Args:
            parser:
            parser_name:
        """

        self.parser = parser
        """A `parsers.Parser` instance shared by all doctrees.  May be left
        unspecified if the document source determines the parser."""

        if parser is None and parser_name:
            self.set_parser(parser_name)

        self.source = None
        """`docutils.io` IO object, source of input data."""

        self.input = None
        """Raw text input; either a single string or, for more complex cases,
        a collection of strings."""

    def set_parser(self, parser_name):
        """Set `self.parser` by name.

        Args:
            parser_name:
        """
        parser_class = parsers.get_parser_class(parser_name)
        self.parser = parser_class()

    def read(self, source, parser, settings):
        """
        Args:
            source:
            parser:
            settings:
        """
        self.source = source
        if not self.parser:
            self.parser = parser
        self.settings = settings
        self.input = self.source.read()
        self.parse()
        return self.document

    def parse(self):
        """Parse `self.input` into a document tree."""
        self.document = document = self.new_document()
        self.parser.parse(self.input, document)
        document.current_source = document.current_line = None

    def new_document(self):
        """Create and return a new empty document tree (root node)."""
    """Locate and return a role function from its language-dependent name, along
    with a list of system messages. If the role is not found in the current
    language, check English. Return a 2-tuple: role function (``None`` if the
    named role cannot be found) and a list of system messages.

    Args:
        role_name:
        language_module:
        lineno:
        reporter:
    """
    """A reader which rereads an existing document tree (e.g. a deserializer).

    Often used in conjunction with `writers.UnfilteredWriter` .
    """

    def get_transforms(self):
        # Do not add any transforms.  They have already been applied
        # by the reader which originally created the document.
        return Component.get_transforms(self)


_reader_aliases = {}

def get_reader_class(reader_name):
    """Return the Reader class from the `reader_name` module.

    Args:
        reader_name:
    """
    reader_name = reader_name.lower()
    if reader_name in _reader_aliases:
        reader_name = _reader_aliases[reader_name]
    try:
        module = __import__(reader_name, globals(), locals(), level=1)
    except ImportError:
        module = __import__(reader_name, globals(), locals(), level=0)
    return module.Reader

        """
        Args:
    """Stores data attributes for dotted-attribute access."""
            arg_block:
        """
        """
        Args:
            **keywordargs:
        """
        """
        Args:
            option_presets:
            option_spec:
            arg_block:
    """reStructuredText's master StateMachine.

    The entry point to reStructuredText parsing is the `run()` method.
    """
            directive:
            option_presets:
        """
        """Parse `input_lines` and modify the `document` node in place.

        Extend `StateMachineWS.run()` : set up parse-global data and run the
        StateMachine.

        Args:
            input_lines:
            document:
            input_offset:
            match_titles:
            inliner:
        """

        - `match` : A regular expression match object which matched the first
          line of the directive.

        - `type_name` : The directive name, as used in the source text.

        - `option_presets` : A dictionary of preset options, defaults for the
          directive options. Currently, only an "alt" option is passed by
          substitution definitions (value: the substitution name), which may be
          used by an embedded image directive.

        Returns a 2-tuple: list of nodes, and a "blank finish" boolean.

        Args:
            directive:
            match:
            type_name:
            option_presets:
        """
        """Returns a 2-tuple: list of nodes, and a "blank finish" boolean.

        Args:
            match:
            **option_presets:
        """
    """StateMachine run from within other StateMachine runs, to parse nested
    document structures.
    """
        """
        Args:
        """Parse `input_lines` and populate a `docutils.nodes.document`
        instance.

        Extend `StateMachineWS.run()` : set up document-wide data.

        Args:
            input_lines:
            input_offset:
            memo:
            node:
            match_titles:
        """
            refuri:
            target:
            lineno:
        """
        """
        Args:
            reference:
        """
        """Determine the type of reference of a target.

        Args:
            block:
            block_text:
            lineno:

    """reStructuredText State superclass.

    Contains methods used by all State subclasses.
    """
            - 'malformed' and a system_message node
        """
        """
        Args:
            block:
        """
        Args:
            state_machine:
            debug:
        """
            block_text:
            lineno:
            target_name:
        """
        """
        Args:
            match:
        """
        """
        Args:
            match:
        """
        """
        Args:
            match:
        """
        """
        Args:
        """Jump to input line `abs_line_offset` , ignoring jumps past the end.

        Args:
            abs_line_offset:
        """
        """
        Args:
            tabledata:
            tableline:
            stub_columns:
            widths:
        """Override `StateWS.no_match` to generate a system message.

        This code should never be run.

        Args:
            context:
            transitions:
        """
            offset:
        """
        """Parse a table.

        Args:
            isolate_function:
            parser_class:
        """
        """Called at beginning of file.

        Args:
            context:
        """

        Args:
            match:
            context:
        """Create a new StateMachine rooted at `node` and run it over the input
        `block` .

        Args:
            block:
            input_offset:
            node:
            match_titles:
            state_machine_class:
            state_machine_kwargs:
        """
        """Top border of a simple table.

        Args:
            match:
            context:
            next_state:
        """
        """Top border of a full table.

        Args:
            match:
            context:
            next_state:
        """
        """
        Args:
            block:
        """
        """
        Args:
            block:
        """
        """Return one line element of a line_block.

        Args:
            match:
            lineno:
        """
        """First line of a line block.

        Args:
            match:
            context:
            next_state:
        """
        """
        Args:
            match:
        """Create a new StateMachine rooted at `node` and run it over the input
        `block` . Also keep track of optional intermediate blank lines and the
        required final one.

        Args:
            block:
            input_offset:
            node:
            initial_state:
            blank_finish:
            blank_finish_state:
            extra_settings:
            match_titles:
            state_machine_class:
            state_machine_kwargs:
        """

        Args:
            match:

        Raises:
            * `MarkupError` for invalid option markers.
        """
        """
        Args:
            match:
        """
        """Option list item.

        Args:
            match:
            context:
            next_state:
        """
        """
        """Check for a valid subsection and create one if it checks out.

        Args:
            title:
            source:
            style:
            lineno:
            messages:
        """
            indented:
            offset:
            node:
        """
        """Check for a valid subsection header. Return 1 (true) or None (false).

        When a new section is reached that isn't a subsection of the current
        section, back up the line count (use ``previous_line(-x)``), then
        ``raise EOFError``. The current StateMachine will finish, then the
        calling StateMachine can re-examine the title. This will work its way
        back up the calling chain until the correct section level isreached.

        @@@ Alternative: Evaluate the title, store the title info & level,
        and back up the chain until that level is reached. Store in memo? Or
        return in results?

        Args:
            source:
            style:
            lineno:

        Raises:
            * `EOFError` when a sibling or supersection encountered.
        """
        """
        """Construct and return the next enumerated list item marker, and an
        auto-enumerator ("#" instead of the regular enumerator).

        Return ``None`` for invalid (out of range) ordinals.

        Args:
            ordinal:
            sequence:
            format:
        """
        """Check validity based on the ordinal value and the second line.

        Return true if the ordinal is valid and the second line is blank,
        indented, or starts with the next enumerator or an auto-enumerator.

        Args:
            ordinal:
            sequence:
            format:
        """
        """Analyze an enumerator and return the results.

        The enumerator format has already been determined by the regular
        expression match. If `expected_sequence` is given, that sequence is
        tried first. If not, we check for Roman numeral 1. This way,
        """
        Args:
            sourcetext:
            lineno:
        """
        single-character Roman numerals (which are also alphabetical) can be
        matched. If no sequence has been matched, all sequences are checked in
        order.

        Args:
            match:
        """Append new subsection to document tree. On return, check level.

        Args:
            title:
            lineno:
            messages:
        """

        Returns:
            - the enumerator format ('period', 'parens', or 'rparen'),
            - the sequence used ('arabic', 'loweralpha', 'upperroman', etc.),
            - the text of the enumerator, stripped of formatting, and
            - the ordinal value of the enumerator ('a' -> 1, 'ii' -> 2, etc.;
              ``None`` is returned for invalid enumerator text).
        """
        """Enumerated List Item

        Args:
            match:
            context:
            next_state:
        """
        """
        Args:
            indent:
        """
        """Bullet list item.

        Args:
            match:
            context:
            next_state:
        """Return a list (paragraph & messages) & a boolean: literal_block next?

        Args:
            lines:
            lineno:
        """
            indented:
            line_offset:
        """
        """Check attribution shape. Return the index past the end of the
        attribution, and the indent.

        Args:
            indented:
            attribution_start:
        """
        """Check for a block quote attribution and split it off:

        * First line after a blank line must begin with a dash ("--", "---",
          em-dash; matches `self.attribution_pattern` ).
        * Every line after that must have consistent indentation.
        * Attributions must be preceded by block quote content.

        Return a tuple of: (block quote content lines, content offset,
        """Return 2 lists: nodes (text and inline elements), and
        system_messages.

        Args:
            text:
            lineno:
        """
            indented:
            line_offset:
        """
        """
        Args:
            indented:
        """
        Args:
            node_name:
        """
            line_offset:
        """
        """Block quote.

        Args:
            match:
            context:
    """Build, compile and return a regular expression based on `definition` .

    Args:
        definition:
        compile:
    """
    """
    Args:
        s:
        _zero:
    """
    """
    Args:
        s:
        _zero:
    """
        """Check each of the patterns in `self.implicit_dispatch` for a match,
        and dispatch to the stored method for the pattern. Recursively check the
        text before and after the match. Return a list of `nodes.Text` and
        inline element nodes.

        Args:
            text:
    """Parse inline markup; call the `parse()` method."""
        Args:
            match:
            lineno:
        """
        """
        Args:
            match:
            lineno:
        """
        Args:
            settings:
        """
        """
        """
        Args:
            match:
            lineno:
        """
        """
        Args:
            match:
            lineno:
        """
        """
        Args:
            match:
            lineno:
            anonymous:
        """
        """Handles `nodes.footnote_reference` and `nodes.citation_reference`
        elements.

        Args:
            match:
            lineno:
        """
        """
        Args:
            match:
            lineno:
        """
        """
        Args:
            match:
            lineno:
        """
        """
        Args:
            match:
            lineno:
        """
        """
        Args:
            rawsource:
            text:
            role:
            lineno:
        """
        """
        Args:
            uri:
        """
        """
        Args:
            before:
            after:
            rawsource:
            escaped:
            text:
        """
        """
        Args:
            match:
            lineno:
        """
        """
        Args:
            match:
            lineno:
        """
        """
        Args:
            match:
            lineno:
        """
        """
        Args:
            text:
            rawsource:
            message:
        """
        """
        Args:
            match:
            lineno:
            end_pattern:
            nodeclass:
            restore_backslashes:
        """
        """Test if inline markup start-string is 'quoted'.

        'Quoted' in this context means the start-string is enclosed in a pair
        of matching opening/closing delimiters (not necessarily quotes) or at
        the end of the match.

        Args:
            match:
        """
        """Return 2 lists: nodes (text and inline elements), and
        system_messages.

        Using `self.patterns.initial` , a pattern which matches start-strings
        (emphasis, strong, interpreted, phrase reference, literal, substitution
        reference, and inline target) and complete constructs (simple reference,
        footnote reference), search for a candidate. When one is found, check
        for validity (e.g., not a quoted '*' character). If valid, search for
        the corresponding end string if applicable, and check it for validity.
        If not found or invalid, generate a warning and ignore the start-string.
        Implicit inline markup (e.g. standalone URIs) is found last.

        Args:
            text:
            lineno:
            memo:
            parent:
        """