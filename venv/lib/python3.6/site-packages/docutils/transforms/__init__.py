# $Id: __init__.py 8238 2018-11-21 19:09:09Z milde $
# Authors: David Goodger <goodger@python.org>; Ueli Schlaepfer
# Copyright: This module has been placed in the public domain.

"""
This package contains modules for standard tree transforms available
to Docutils components. Tree transforms serve a variety of purposes:

- To tie up certain syntax-specific "loose ends" that remain after the
  initial parsing of the input plaintext. These transforms are used to
  supplement a limited syntax.

- To automate the internal linking of the document tree (hyperlink
  references, footnote references, etc.).

- To extract useful information from the document tree. These
  transforms may be used to construct (for example) indexes and tables
  of contents.

Each transform is an optional step that a Docutils component may
choose to perform on the parsed document.
"""

__docformat__ = 'reStructuredText'


from docutils import languages, ApplicationError, TransformSpec


class TransformError(ApplicationError): pass


class Transform:

    """Docutils transform component abstract base class."""

    default_priority = None
    """Numerical priority of this transform, 0 through 999 (override)."""

    def __init__(self, document, startnode=None):
        """Initial setup for in-place document transforms.

        Args:
            document:
            startnode:
        """

        self.document = document
        """The document tree to transform."""

        self.startnode = startnode
        """Node from which to begin the transform.  For many transforms which
        apply to the document as a whole, `startnode` is not set (i.e. its
        value is `None`)."""

        self.language = languages.get_language(
            document.settings.language_code, document.reporter)
        """Language module local to this document."""

    def apply(self, **kwargs):
        """Override to apply the transform to the document tree.

        Args:
            **kwargs:
        """
        raise NotImplementedError('subclass must override this method')


class Transformer(TransformSpec):

    """Stores transforms ( `Transform` classes) and applies them to document
    trees. Also keeps track of components by component type name.
    """

    def __init__(self, document):
        """
        Args:
            document:
        """
        self.transforms = []
        """List of transforms to apply.  Each item is a 4-tuple:
        ``(priority string, transform class, pending node or None, kwargs)``.
        """

        self.unknown_reference_resolvers = []
        """List of hook functions which assist in resolving references"""

        self.document = document
        """The `nodes.document` object this Transformer is attached to."""

        self.applied = []
        """Transforms already applied, in order."""

        self.sorted = 0
        """Boolean: is `self.tranforms` sorted?"""

        self.components = {}
        """Mapping of component type name to component object.  Set by
        `self.populate_from_components()`."""

        self.serialno = 0
        """Internal serial number to keep track of the add order of
        transforms."""

    def add_transform(self, transform_class, priority=None, **kwargs):
        """Store a single transform. Use `priority` to override the default.
        `kwargs` is a dictionary whose contents are passed as keyword arguments
        to the `apply` method of the transform. This can be used to pass
        application-specific data to the transform instance.

        Args:
            transform_class:
            priority:
            **kwargs:
        """
        if priority is None:
            priority = transform_class.default_priority
        priority_string = self.get_priority_string(priority)
        self.transforms.append(
            (priority_string, transform_class, None, kwargs))
        self.sorted = 0

    def add_transforms(self, transform_list):
        """Store multiple transforms, with default priorities.

        Args:
            transform_list:
        """
        for transform_class in transform_list:
            priority_string = self.get_priority_string(
                transform_class.default_priority)
            self.transforms.append(
                (priority_string, transform_class, None, {}))
        self.sorted = 0
    """A finite state machine for text filters using regular expressions.

    The input is provided in the form of a list of one-line strings (no
    newlines). States are subclasses of the `State` class. Transitions consist
    of regular expression patterns and transition methods, and are defined in
    each state.

    The state machine is started with the `run()` method, which returns the
    results of processing in a list.
    """
        priority_string = self.get_priority_string(priority)
        self.transforms.append(
            (priority_string, transform_class, pending, {}))
        self.sorted = 0

    def get_priority_string(self, priority):
        """Return a string, `priority` combined with `self.serialno` .

        This ensures FIFO order on transforms with identical priority.

        Args:
            priority:
        """
        - `debug` : a boolean; produce verbose output if true (nonzero).

        Args:
            state_classes:
            initial_state:
            debug:
        """
        Also, store components by type name in a mapping for later lookup.

        Args:
            components:
        """
        for component in components:
            if component is None:
                continue
            self.add_transforms(component.get_transforms())
            self.components[component.component_type] = component
        self.sorted = 0
        # Set up all of the reference resolvers for this transformer. Each
        # component of this transformer is able to register its own helper
        # functions to help resolve references.
        unknown_reference_resolvers = []
        for i in components:
            unknown_reference_resolvers.extend(i.unknown_reference_resolvers)
        decorated_list = [(f.priority, f) for f in unknown_reference_resolvers]
        decorated_list.sort()
        self.unknown_reference_resolvers.extend([f[1] for f in decorated_list])

    def apply_transforms(self):
        """Apply all of the stored transforms, in priority order."""
        self.document.reporter.attach_observer(
            self.document.note_transform_message)
        while self.transforms:
            if not self.sorted:
                # Unsorted initially, and whenever a transform is added.
                self.transforms.sort()
                self.transforms.reverse()
                self.sorted = 1
            priority, transform_class, pending, kwargs = self.transforms.pop()
            transform = transform_class(self.document, startnode=pending)
            transform.apply(**kwargs)
            self.applied.append((priority, transform_class, pending, kwargs))

    """
    `StateMachine` subclass specialized for whitespace recognition.

    There are three methods provided for extracting indented text blocks:
        """Remove circular references to objects no longer required."""
    - `get_indented()` : use when the indent is unknown.
    - `get_known_indented()` : use when the indent is known for all lines.
    - `get_first_known_indented()` : use when only the first line's indent is
      known.
    """
        """A "do nothing" transition method.
        """Run the state machine on `input_lines` . Return results (a list).

        Reset `self.line_offset` and `self.current_state` . Run the
        beginning-of-file transition. Input one line at a time and check for a
        matching transition. If a match is found, call the transition method and
        possibly change the state. Store the context returned by the transition
        method to be passed on to the next transition matched. Accumulate the
        results returned by the transition methods in a list. Run the
        end-of-file transition. Finally, return the accumulated results.

        Parameters:

        - `input_lines` : a list of strings without newlines, or `StringList` .
        - `input_offset` : the line offset of `input_lines` from the beginning
          of the file.
        - `context` : application-specific storage.
        - `input_source` : name or path of source of `input_lines` .
        - `initial_state` : name of initial state.

        Args:
            input_lines:
            input_offset:
            context:
            input_source:
            initial_state:
        """

        Parameter `context` : application-defined storage.

        Args:
            context:
        """
        """Called when there is no match from `StateMachine.check_line()` .

        Return the same values returned by transition methods:

        - context: unchanged;
        - next state name: ``None``;
        - empty result list.

        Override in subclasses to catch this event.

        Args:
            context:
            transitions:
        """
        """Return a list of transition names and a transition mapping.

        Parameter `name_list` : a list, where each entry is either a
        transition name string, or a 1- or 2-tuple (transition name, optional
        next state name).

        Args:
            name_list:
        """
        """Make & return a transition tuple based on `name` .

        This is a convenience function to simplify transition creation.

        Parameters:

        - `name` : a string, the name of the transition pattern & method. This
          `State` object must have a method called ' `name` ', and a dictionary
          `self.patterns` containing a key ' `name` '.
        - `next_state` : a string, the name of the next `State` object for this
          transition. A value of ``None`` (or absent) implies no state change
          (i.e., continue with the same state).

        Exceptions: `TransitionPatternNotFound` , `TransitionMethodNotFound`
        .

        Args:
            name:
            next_state:
        """
        """Remove a transition by `name` .

        Exception: `UnknownTransitionError` .

        Args:
            name:
        """
        """Add a transition to the start of the transition list.

        Parameter `transition` : a ready-made transition 3-tuple.

        Exception: `DuplicateTransitionError` .

        Args:
            name:
            transition:
        """
        """Add a list of transitions to the start of the transition list.

        - `names` : a list of transition names.
        - `transitions` : a mapping of names to transition tuples.

        Exceptions: `DuplicateTransitionError` , `UnknownTransitionError` .

        Args:
            names:
        """Return current state object; set it first if `next_state` given.

        Parameter `next_state` : a string, the name of the next state.

        Exception: `UnknownStateError` raised if `next_state` unknown.

        Args:
            next_state:
        """
        """Initialize a `State` object; make & add initial transitions.

        - `statemachine` : the controlling `StateMachine` object.
        - `debug` : a boolean; produce verbose output if true.

        Args:
            state_machine:
            debug:
        """
    """State superclass. Contains a list of transitions, and transition methods.

    Transition methods all have the same signature. They take 3 parameters:

    - An `re` match object. ``match.string`` contains the matched input line,
        """Load `self.line` with the `n` 'th next line and return it.

        Args:
            n:
        """
      gives the end index.
    - A context object, whose meaning is application-defined (initial value
      ``None``). It can be used to store any information required by the state
      machine, and the retured context is passed on to the next transition
      method unchanged.
    - The name of the next state, a string, taken from the transitions list;
      normally it is returned unchanged, but it may be altered by the transition
      method if necessary.

    Transition methods all return a 3-tuple:

    - A context object, as (potentially) modified by the transition method.
        """Return 1 if the next line is blank or non-existant."""
    - The processing result, a list, which is accumulated by the state machine.

    Transition methods may raise an `EOFError` to cut processing short.

    There are two implicit transitions, and corresponding transition methods
    are defined: `bof()` handles the beginning-of-file, and `eof()` handles the
        """Return 1 if the input is at or past end-of-file."""
    `bof()` returns the initial context and results, and may be used to return a
    header string, or do any other processing needed. `eof()` should handle any
    remaining context and wrap things up; it returns the final processing
        """Return 1 if the input is at or before beginning-of-file."""

    Typical applications need only subclass `State` (or a subclass), set the
    `patterns` and `initial_transitions` class attributes, and provide
        """Load `self.line` with the `n` 'th previous line and return it.

        Args:
            n:
        """
    take care of constructing the list of transitions.
    """
        """
        Args:
            observer:
        """
        """The `observer` parameter is a function or bound method which takes
        two arguments, the source and offset of the current line.

        """Jump to absolute line offset `line_offset` , load and return it.

        Args:
            line_offset:
        """
            observer:
        """
        """Report error details."""
        """Initialize `self.states` ."""
        """Add `state_classes` (a list of `State` subclasses).

        Args:
            state_classes:
        """
        """Initialize & add a `state_class` ( `State` subclass) object.

        Exception: `DuplicateStateError` raised if `state_class` was already
        """Return source of line at absolute line offset `line_offset` .

        Args:
            line_offset:
        """

        Args:
            state_class:
        """Return line offset of current line, from beginning of file."""
        """Examine one line of input for a transition match & execute its
        method.

        """Return line number of current line (counting from 1)."""

        - `context` : application-dependent storage.
        - `state` : a `State` object, the current state.
        """Return (source, line) tuple for current or given line number.

        Looks up the source and line number in the `self.input_lines`
        StringList instance to count for included source files.

        If the optional argument `lineno` is given, convert it from an
        absolute line number to the corresponding (source, line) pair.

        Args:
            lineno:
        """

        When there is no match, ``state.no_match()`` is called and its return
        value is returned.

        Args:
            context:
            state:
            transitions:
        """
        """Return a contiguous block of text.

        If `flush_left` is true, raise `UnexpectedIndentationError` if an
        indented line is encountered before the text block ends (with a blank
        line).

        Args:
            flush_left:
        """
        """
        Args:
            input_lines:
            source:
        """