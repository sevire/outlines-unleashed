# $Id: components.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: David Goodger <goodger@python.org>
# Copyright: This module has been placed in the public domain.

"""
Docutils component-related transforms.
"""

__docformat__ = 'reStructuredText'

import sys
import os
import re
import time
from docutils import nodes, utils
from docutils import ApplicationError, DataError
from docutils.transforms import Transform, TransformError


class Filter(Transform):

    """Include or exclude elements which depend on a specific Docutils
    component.

    For use with `nodes.pending` elements. A "pending" element's dictionary
    attribute ``details`` must contain the keys "component" and "format". The
    value of ``details['component']`` must match the type name of the component
    the elements depend on (e.g. "writer"). The value of ``details['format']``
    is the name of a specific format or context of that component (e.g. "html").
    If the matching Docutils component supports that format or context, the
    "pending" element is replaced by the contents of ``details['nodes']`` (a
    list of nodes); otherwise, the "pending" element is removed.

    For example, the reStructuredText "meta" directive creates a "pending"
    element containing a "meta" element (in ``pending.details['nodes']``). Only
    writers (``pending.details['component'] == 'writer'``) supporting the "html"
    format (``pending.details['format'] == 'html'``) will include the "meta"
    element; it will be deleted from the output of all other writers.
    """

    default_priority = 780

    def apply(self):
        pending = self.startnode
        component_type = pending.details['component'] # 'reader' or 'writer'
        format = pending.details['format']
        component = self.document.transformer.components[component_type]
        if component.supports(format):
            pending.replace_self(pending.details['nodes'])
        else:
            pending.parent.remove(pending)

    """
    `StateMachine` subclass specialized for whitespace recognition.

    There are three methods provided for extracting indented text blocks:

    - `get_indented()` : use when the indent is unknown.
    - `get_known_indented()` : use when the indent is known for all lines.
    - `get_first_known_indented()` : use when only the first line's indent is
      known.
    """
        """A "do nothing" transition method.

        Return unchanged `context` & `next_state` , empty result. Useful for
        simple state changes (actionless transitions).

        Args:
            match:
            context:
            next_state:
        """
        """Handle end-of-file. Return empty result.

        Override in subclasses.

        Parameter `context` : application-defined storage.

        Args:
            context:
        """
        """Handle beginning-of-file. Return unchanged `context` , empty result.

        Override in subclasses.

        Parameter `context` : application-defined storage.

        Args:
            context:
        """
        """Called when there is no match from `StateMachine.check_line()` .

        Return the same values returned by transition methods:

        - context: unchanged;
        - next state name: ``None``;
        - empty result list.

        Override in subclasses to catch this event.

        Args:
            context:
            transitions:
        """
        """Return a list of transition names and a transition mapping.

        Parameter `name_list` : a list, where each entry is either a
        transition name string, or a 1- or 2-tuple (transition name, optional
        next state name).

        Args:
            name_list:
        """
        """Make & return a transition tuple based on `name` .

        This is a convenience function to simplify transition creation.

        Parameters:
    """A finite state machine for text filters using regular expressions.

    The input is provided in the form of a list of one-line strings (no
    newlines). States are subclasses of the `State` class. Transitions consist
    of regular expression patterns and transition methods, and are defined in
    each state.

    The state machine is started with the `run()` method, which returns the
    results of processing in a list.
    """
        Args:
            name:
        """Initialize a `StateMachine` object; add state objects.

        - `state_classes` : a list of `State` (sub)classes.
        - `initial_state` : a string, the class name of the initial state.
        - `debug` : a boolean; produce verbose output if true (nonzero).

        Args:
            state_classes:
            initial_state:
            debug:
        """
        """Add a transition to the start of the transition list.

        Parameter `transition` : a ready-made transition 3-tuple.

        Exception: `DuplicateTransitionError` .

        Args:
            name:
            transition:
        """
        """Add a list of transitions to the start of the transition list.

        - `names` : a list of transition names.
        - `transitions` : a mapping of names to transition tuples.

        Exceptions: `DuplicateTransitionError` , `UnknownTransitionError` .

        Args:
            names:
            transitions:
        """
        """Make and add transitions listed in `self.initial_transitions` ."""
        """Remove circular references to objects no longer required."""
        """Initialize this `State` before running the state machine; called from
        `self.state_machine.run()` .
        """
        """Initialize a `State` object; make & add initial transitions.

        - `statemachine` : the controlling `StateMachine` object.
        - `debug` : a boolean; produce verbose output if true.

        Args:
            state_machine:
            debug:
        """
    """State superclass. Contains a list of transitions, and transition methods.

    Transition methods all have the same signature. They take 3 parameters:
        """Remove circular references to objects no longer required."""
    - An `re` match object. ``match.string`` contains the matched input line,
      ``match.start()`` gives the start index of the match, and ``match.end()``
      gives the end index.
    - A context object, whose meaning is application-defined (initial value
      ``None``). It can be used to store any information required by the state
      machine, and the retured context is passed on to the next transition
        """Run the state machine on `input_lines` . Return results (a list).

        Reset `self.line_offset` and `self.current_state` . Run the
        beginning-of-file transition. Input one line at a time and check for a
        matching transition. If a match is found, call the transition method and
        possibly change the state. Store the context returned by the transition
        method to be passed on to the next transition matched. Accumulate the
        results returned by the transition methods in a list. Run the
        end-of-file transition. Finally, return the accumulated results.

        Parameters:

        - `input_lines` : a list of strings without newlines, or `StringList` .
        - `input_offset` : the line offset of `input_lines` from the beginning
          of the file.
        - `context` : application-specific storage.
        - `input_source` : name or path of source of `input_lines` .
        - `initial_state` : name of initial state.

        Args:
            input_lines:
            input_offset:
            context:
            input_source:
            initial_state:
        """
    Typical applications need only subclass `State` (or a subclass), set the
    `patterns` and `initial_transitions` class attributes, and provide
    corresponding transition methods. The default object initialization will
    take care of constructing the list of transitions.
    """
        """
        Args:
            observer:
        """
        """The `observer` parameter is a function or bound method which takes
        two arguments, the source and offset of the current line.

        Args:
            observer:
        """
        """Report error details."""
        """Initialize `self.states` ."""
        """Add `state_classes` (a list of `State` subclasses).

        Args:
            state_classes:
        """
        """Initialize & add a `state_class` ( `State` subclass) object.

        Exception: `DuplicateStateError` raised if `state_class` was already
        added.

        Args:
            state_class:
        """
        """Examine one line of input for a transition match & execute its
        method.

        Parameters:

        - `context` : application-dependent storage.
        - `state` : a `State` object, the current state.
        - `transitions` : an optional ordered list of transition names to try,
          instead of ``state.transition_order``.

        Return the values returned by the transition method:

        - context: possibly modified from the parameter `context` ;
        - next state name ( `State` subclass name);
        - the result output of the transition, a list.

        When there is no match, ``state.no_match()`` is called and its return
        value is returned.

        Args:
            context:
            state:
            transitions:
        """
        """Return a contiguous block of text.

        If `flush_left` is true, raise `UnexpectedIndentationError` if an
        indented line is encountered before the text block ends (with a blank
        line).

        Args:
            flush_left:
        """
        """
        Args:
            input_lines:
            source:
        """
        """Return (source, line) tuple for current or given line number.

        Looks up the source and line number in the `self.input_lines`
        StringList instance to count for included source files.

        If the optional argument `lineno` is given, convert it from an
        absolute line number to the corresponding (source, line) pair.
        """Return current state object; set it first if `next_state` given.

        Parameter `next_state` : a string, the name of the next state.

        Exception: `UnknownStateError` raised if `next_state` unknown.

        Args:
            next_state:
        """

        Args:
            line_offset:
        """
        """Jump to absolute line offset `line_offset` , load and return it.

        Args:
            line_offset:
        """
        """Load `self.line` with the `n` 'th previous line and return it.

        Args:
            n:
        """
        """Load `self.line` with the `n` 'th next line and return it.

        Args:
            n:
        """
        """Return 1 if the input is at or past end-of-file."""
        """Return 1 if the next line is blank or non-existant."""